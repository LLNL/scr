package scr_param;
use strict;

# reads in an SCR hash file and translates it
# into a perl hash object

my $sysconf = "@SCR_CONFIG_FILE@";

sub new
{
  my $type = shift;

  my $self = {};

  $self->{prog} = 'scr_param';
  $self->{usrconf} = {};
  $self->{sysconf} = {};

  # set our compile time constants
  $self->{compile} = {};
  $self->{compile}{"CNTLDIR"}{"@SCR_CNTL_BASE@"} = {};
  $self->{compile}{"CACHEDIR"}{"@SCR_CACHE_BASE@"} = {};
  $self->{compile}{"SCR_CNTL_BASE"}{"@SCR_CNTL_BASE@"} = {};
  $self->{compile}{"SCR_CACHE_BASE"}{"@SCR_CACHE_BASE@"} = {};
  $self->{compile}{"SCR_CACHE_SIZE"}{"1"} = {};

  # set our restricted parameters,
  # these can't be set via env vars or user conf file
  $self->{no_user} = {};
  $self->{no_user}{"SCR_CNTL_BASE"} = {};

  # define user config file
  my $usrfile = undef;
  if (defined $ENV{SCR_CONF_FILE}) {
    # use SCR_CONF_FILE if set
    $usrfile = $ENV{SCR_CONF_FILE};
    $self->{usrconf} = read_config_file($self, $usrfile);
  } else {
    # otherwise, look in the prefix directory
    my $value = get($self, "SCR_PREFIX");
    my $prefix = get_prefix($self, $value);
    $usrfile = "$prefix/.scrconf";
    if (-r $usrfile) {
      $self->{usrconf} = read_config_file($self, $usrfile);
    }
  }

  # read in the app configuration file, if specified
  my $value = get($self, "SCR_PREFIX");
  my $prefix = get_prefix($self, $value);
  my $appfile = "$prefix/.scr/app.conf";
  if (-r $appfile) {
    $self->{appconf} = read_config_file($self, $appfile);
  }

  # read in the system configuration file
  if (defined $sysconf and -r $sysconf) {
    $self->{sysconf} = read_config_file($self, $sysconf);
  }

  # NOTE: At this point we could scan the environment and user config file
  # for restricted parameters to print a warning.  However, in this case
  # printing the extra messages from a perl script whose output is used by
  # other scripts as input may do more harm than good.  Printing the
  # warning in the library should be sufficient.

  # if CACHE_BASE and CACHE_SIZE are set and the user didn't set CACHEDESC,
  # create a single CACHEDESC in the user hash
  my $cache_base = get($self, "SCR_CACHE_BASE");
  my $cache_size = get($self, "SCR_CACHE_SIZE");
  if (not defined $self->{usrconf}{"CACHE"} and
      defined $cache_base and
      defined $cache_size)
  {
    $self->{usrconf}{"CACHE"}{$cache_base}{"SIZE"}{$cache_size} = {};
  }

  return bless $self, $type;
}

# given a string, expand any embedded environment variable names as in
# key=$ENVVAR or key=/home/${USER}/${SLURM_JOBID}
# replaces variable with its value from the environment
sub interpolate_variables
{
  my $raw_value = shift @_;

  my $value = '';
  my @value_parts = split(/(\$\w+)|(\$\{\w+\})/, $raw_value);
  foreach my $seg (@value_parts)
  {
    next if (not defined($seg));
    $seg = ($ENV{$1} || '') if ($seg =~ m/^\$(\w+)/ or $seg =~ m/^\$\{(\w+)\}$/);
    $value .= $seg;
  }

  return $value;
}

sub read_config_file
{
  my $self = shift @_;
  my $file = shift @_;

  my $h = {};

  if (open(IN, $file)) {
    while (my $line = <IN>) {
      chomp $line;
      $line =~ s/^\s*//g; # strip any leading whitespace from line
      $line =~ s/\s*$//g; # strip any trailing whitespace from line
      $line =~ s/=/ /g;   # replace '=' with spaces
      my @parts = split(/\s+/, $line);
      my $top_key   = undef;
      my $top_value = undef;
      while (@parts > 0) {
        my $part = shift @parts;
        if ($part =~ /^#/) {
          @parts = ();
        } else {
          # convert the key to upper case
          my $key = uc($part);

          # read in the value (should have at least one more item in the list)
          if (@parts == 0) {
            print "$self->{prog}: ERROR: Invalid key=value pair detected in $file.\n";
            exit 1;
          }

          # expand any embedded environment variable names as in
          # key=$ENVVAR or key=/home/${USER}/${SLURM_JOBID}
          # replaces variable with its value from the environment
          my $raw_value = shift @parts;
          my $value = interpolate_variables($raw_value);

          # record the key value pair in the hash
          if (defined $top_key) {
            $$h{$top_key}{$top_value}{$key}{$value} = {};
          } else {
            $top_key   = $key;
            $top_value = $value;
            $$h{$top_key}{$top_value} = {};
          }
        }
      }
    }
    # done reading, close the file
    close(IN);
  } else {
    print "$self->{prog}: ERROR: Could not open file: $file\n";
  }

  return $h;
}

sub get
{
  my $self = shift;
  my $name = shift;

  # if param is set in environment, return that value
  if (not defined $self->{no_user}{$name} and defined $ENV{$name}) {
    my $value = interpolate_variables($ENV{$name});
    return $value;
  }

  # otherwise, check whether we have it defined in our user config file
  if (not defined $self->{no_user}{$name} and defined $self->{usrconf}{$name}) {
    my $first = (keys %{$self->{usrconf}{$name}})[0];
    return $first;
  }

  # if param was set by the code, return that value
  if (defined $self->{appconf}{$name}) {
    my $first = (keys %{$self->{appconf}{$name}})[0];
    return $first;
  }

  # otherwise, check whether we have it defined in our system config file
  if (defined $self->{sysconf}{$name}) {
    my $first = (keys %{$self->{sysconf}{$name}})[0];
    return $first;
  }

  # otherwise, check whether its a compile time constant
  if (defined $self->{compile}{$name}) {
    my $first = (keys %{$self->{compile}{$name}})[0];
    return $first;
  }

  return undef;
}

sub get_prefix
{
  my $self = shift;
  my $prefix = shift;

  if (not defined($prefix)) {
    # get current working dir
    $prefix = `pwd`;
    chomp $prefix;
  }

  # tack on current working dir if needed
  # don't resolve symlinks
  # don't worry about missing parts, the calling script calling might create it
  $prefix = `realpath -m -s $prefix`;
  chomp $prefix;

  return $prefix;
}

sub get_hash
{
  my $self = shift;
  my $name = shift;

  # if param is set in environment, return that value
  if (not defined $self->{no_user}{$name} and defined $ENV{$name}) {
    my $h = {};
    $h->{interpolate_variables($ENV{$name})} = {};
    return $h;
  }

  # otherwise, check whether we have it defined in our user config file
  if (not defined $self->{no_user}{$name} and defined $self->{usrconf}{$name}) {
    my $h = {};
    %$h = %{$self->{usrconf}{$name}};
    return $h;
  }

  # otherwise, check whether we have it defined in our system config file
  if (defined $self->{sysconf}{$name}) {
    my $h = {};
    %$h = %{$self->{sysconf}{$name}};
    return $h;
  }

  # otherwise, check whether its a compile time constant
  if (defined $self->{compile}{$name}) {
    my $h = {};
    %$h = %{$self->{compile}{$name}};
    return $h;
  }

  return undef;
}

# convert byte string like 2kb, 1.5m, 200GB, 1.4T to integer value
sub abtoull
{
  my $self = shift;
  my $str  = shift;

  # break string into number and units
  my $number = undef;
  my $units  = undef;
  if ($str =~ /^(\d+\.\d+)(\D+)$/) {
    # got something like "2.5GB"
    $number = $1;
    $units  = $2;
  } elsif ($str =~ /^(\d+)(\D+)$/) {
    # got something like "2GB"
    $number = $1;
    $units  = $2;
  } else {
    # just take what the user has verbatim
    $number = $str;
  }

  # parse units if we have them
  my $factor = undef;
  if (defined $units) {
    if ($units =~ /^[bB]$/) {
      $factor = 1;
    } elsif ($units =~ /^[kK][bB]?$/) {
      $factor = 1024;
    } elsif ($units =~ /^[mM][bB]?$/) {
      $factor = 1024 * 1024;
    } elsif ($units =~ /^[gG][bB]?$/) {
      $factor = 1024 * 1024 * 1024;
    } elsif ($units =~ /^[tT][bB]?$/) {
      $factor = 1024 * 1024 * 1024 * 1024;
    } elsif ($units =~ /^[pP][bB]?$/) {
      $factor = 1024 * 1024 * 1024 * 1024 * 1024;
    } elsif ($units =~ /^[eE][bB]?$/) {
      $factor = 1024 * 1024 * 1024 * 1024 * 1024 * 1024;
    } else {
      # TODO: print error?
      # unknown unit string
    }
  }

  # set value to number portion
  my $val = $number;
  if (defined $factor) {
    # multiply by factor if we have one
    $val *= $factor;
  } elsif (defined $units) {
    # got a units string, but couldn't parse it
    $val = "0";
  }

  # chop off any trailing decimals
  $val = int($val);

  return $val;
}

1;
